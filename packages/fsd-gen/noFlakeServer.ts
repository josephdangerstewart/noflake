// DO NOT EDIT: generated by fsdgenjs
/* eslint-disable */

import * as bodyParser from 'body-parser';
import * as express from 'express';
import { IServiceResult } from 'facility-core';
import { INoFlake, ICreateProjectRequest, ICreateProjectResponse, ISubmitTestSuiteResultRequest, ISubmitTestSuiteResultResponse, IProject, ITestSuiteResult, ITestResult, ITestId, TestResultStatus } from './noFlakeTypes';
export * from './noFlakeTypes';

const standardErrorCodes: { [code: string]: number } = {
	'NotModified': 304,
	'InvalidRequest': 400,
	'NotAuthenticated': 401,
	'NotAuthorized': 403,
	'NotFound': 404,
	'Conflict': 409,
	'RequestTooLarge': 413,
	'TooManyRequests': 429,
	'InternalError': 500,
	'ServiceUnavailable': 503,
};

function parseBoolean(value: string | undefined) {
	if (typeof value === 'string') {
		const lowerValue = value.toLowerCase();
		if (lowerValue === 'true') {
			return true;
		}
		if (lowerValue === 'false') {
			return false;
		}
	}
	return undefined;
}

export function createApp(service: INoFlake): express.Application {
	const app = express();
	app.use(bodyParser.json());
	app.use(bodyParser.urlencoded({ extended: true }));

	app.post('/createProject', function (req, res, next) {
		const request: ICreateProjectRequest = {};

		return service.createProject(request)
			.then(result => {
				if (result.error) {
					const status = result.error.code && standardErrorCodes[result.error.code] || 500;
					res.status(status).send(result.error);
					return;
				}
				if (result.value) {
					res.status(200).send({
						project: result.value.project,
					});
					return;
				}
				throw new Error('Result must have an error or value.');
			})
			.catch(next);
	});

	app.post('/submitTestSuiteResult', function (req, res, next) {
		const request: ISubmitTestSuiteResultRequest = {};
		request.result = req.body.result;

		return service.submitTestSuiteResult(request)
			.then(result => {
				if (result.error) {
					const status = result.error.code && standardErrorCodes[result.error.code] || 500;
					res.status(status).send(result.error);
					return;
				}
				if (result.value) {
					res.sendStatus(200);
					return;
				}
				throw new Error('Result must have an error or value.');
			})
			.catch(next);
	});

	return app;
}
